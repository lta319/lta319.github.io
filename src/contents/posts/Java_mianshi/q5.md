---
title: JVM 的主要内存区域
published: 2025-05-10
description: 详细说说 JVM 的主要内存区域（程序计数器、虚拟机栈、本地方法栈、堆、方法区/元空间）各自的作用、线程共享/私有性以及可能出现的异常
tags: [Markdown, Blogging]
category: Java mianshi
licenseName: "Unlicensed"
author: Ankou
sourceLink: ''
draft: false
---
你提到了运行时数据区（内存区域）。详细说说 JVM 的主要内存区域（程序计数器、虚拟机栈、本地方法栈、堆、方法区/元空间）各自的作用、线程共享/私有性以及可能出现的异常（如 StackOverflowError, OutOfMemoryError）

**1. 程序计数器 (Program Counter Register)**

- 作用：
  - 可以看作是**当前线程所执行的字节码的行号指示器**。它记录着下一条需要执行的字节码指令的地址（偏移量）。
  - 在分支、循环、跳转、异常处理、线程恢复等操作发生时，程序计数器用于确保正确找到下一条要执行的指令。
  - 执行 **`native` 方法**（本地方法，如 JNI 调用）时，程序计数器的值为 **`undefined`**。
- **线程私有性：** **线程私有**。每个线程启动时，都会创建自己独立的程序计数器。这是为了在线程切换后能够恢复到正确的执行位置。各线程之间的计数器互不影响。
- **可能出现的异常：** **无**。程序计数器是 JVM 规范中**唯一没有规定任何 `OutOfMemoryError` 情况**的区域。它的生命周期与线程相同。

**2. Java 虚拟机栈 (Java Virtual Machine Stacks)**

- 作用：
  - 描述 Java 方法执行的内存模型。每个方法在执行时，都会同步创建一个栈帧用于存储：
    - **局部变量表 (Local Variables)：** 存放编译期可知的各种**基本数据类型**（`boolean`, `byte`, `char`, `short`, `int`, `float`, `long`, `double`）、**对象引用**（`reference` 类型，指向对象在堆中的地址）和 **`returnAddress` 类型**（指向一条字节码指令的地址）。
    - **操作数栈 (Operand Stack)：** 用于**方法执行过程中的计算工作**（类似 CPU 寄存器）。操作指令从这里读取操作数，也将计算结果压入/弹出操作数栈。
    - **动态链接 (Dynamic Linking)：** 指向运行时常量池中该栈帧所属方法的引用，用于支持方法调用过程中的**动态绑定**（多态）。
    - **方法返回地址 (Return Address)：** 方法正常退出或异常退出时，需要返回到调用该方法的位置继续执行。
  - 方法从调用开始到执行完成，对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
- **线程私有性：** **线程私有**。每个线程都有自己独立的虚拟机栈。
- 可能出现的异常：
  - StackOverflowError`：当线程请求的栈深度超过虚拟机所允许的最大深度时抛出。常见原因：
    - 深度递归调用（没有正确的终止条件）。
    - 存在大量方法嵌套调用（虽然不一定是递归）。
    - 栈帧过大（如局部变量表包含超大数组）。
  - **`OutOfMemoryError`：** 如果 JVM 栈的**内存区域无法申请到足够的内存**来创建新的栈帧时抛出。这通常发生在**创建新线程**时，因为需要为新线程分配私有的虚拟机栈空间。相比于栈深度溢出，这种情况较少见，因为线程数通常有限制。可以通过 `-Xss` 参数设置每个线程栈的大小。

**3. 本地方法栈 (Native Method Stacks)**

- **作用：** 与虚拟机栈功能非常相似，但它是为 JVM 运行 **`native` 方法（非 Java 语言实现的方法，通常用 C/C++ 编写）** 服务的。
- **线程私有性：** **线程私有**。
- 可能出现的异常：
  - **`StackOverflowError`：** 与虚拟机栈类似，本地方法调用深度过大。
  - **`OutOfMemoryError`：** 与虚拟机栈类似，无法为新线程分配本地方法栈或栈扩展时申请不到足够内存。
  - **注意：** HotSpot JVM 将虚拟机栈和本地方法栈合二为一了，所以有时在 HotSpot 中区分不明显。

**4. Java 堆 (Java Heap)**

- 作用：
  - **存放对象实例和数组**。这是 JVM 管理的**最大**的一块内存区域。
  - 几乎所有在运行时通过 `new` 关键字创建的对象实例，以及数组（包括原始类型数组和对象数组）都在堆上分配内存。
  - 垃圾收集器管理的主要区域，因此也称为 **GC 堆 (Garbage Collected Heap)**。堆内存通常被划分为不同的代（如新生代 Eden、Survivor S0/S1，老年代）以优化垃圾回收效率。
  - 堆可以是物理上不连续但逻辑上连续的内存空间。
- **线程私有性：** **线程共享**。所有线程共享堆内存空间。堆中存放的对象可以被所有线程访问，因此是并发访问控制的重点区域。
- 可能出现的异常：
  - OutOfMemoryError`：这是堆内存最常见的错误。当堆中没有足够的空间来分配新对象实例，并且垃圾收集器也无法回收出更多空间时抛出。常见原因：
    - 创建了太多对象且不再使用（**内存泄漏**）。
    - 应用需要处理的数据量过大（如加载超大文件到内存）。
    - 堆内存设置过小 (`-Xms`, `-Xmx` 参数)。
    - 存在大的、无法回收的对象（如错误的缓存设计，缓存了过多数据且无淘汰策略）。
  - **无 `StackOverflowError`**。

**5. 方法区 (Method Area) / 元空间 (Metaspace) (JDK8+)**

- 作用：
  - 在 JDK7 及以前称为 **永久代 (PermGen)**，在 **JDK8 及以后被移除，由元空间 (Metaspace) 取代**。
  - 存储已被虚拟机加载的：
    - **类型信息：** 类的完整有效名、直接父类的完整有效名、修饰符（`public`, `abstract`, `final`）、实现的接口列表。
    - **运行时常量池 (Runtime Constant Pool)：** 每个类或接口在编译期生成的各种**字面量**（文本字符串、`final` 常量值）和**符号引用**（类和接口的全限定名、字段的名称和描述符、方法的名称和描述符）。它是 Class 文件中常量池表的运行时表示。
    - **字段信息：** 字段名称、类型、修饰符。
    - **方法信息：** 方法名称、返回类型、参数数量和类型、修饰符、字节码、操作数栈和局部变量表大小、异常表。
    - **静态变量 (static variables)：** 即类变量。注意：**常量 (`static final`) 通常被优化后存储于运行时常量池中。**
    - **JIT 编译器编译后的代码缓存**（某些 JVM 实现）。
- **线程私有性：** **线程共享**。
- 内存管理：
  - **JDK7 及之前 (永久代)：** 使用 JVM 堆内存的一部分，受 `-XX:PermSize` 和 `-XX:MaxPermSize` 参数控制。
  - JDK8 及之后 (元空间)：
    - 不再使用 JVM 堆内存，而是**使用本地内存 (Native Memory)**。
    - 由 `-XX:MetaspaceSize` 和 `-XX:MaxMetaspaceSize` 参数控制初始大小和上限。如果不设置上限，元空间可以动态扩展，使用所有可用的本地内存（直到系统资源耗尽）。
    - 好处：解决了永久代容易发生 `OutOfMemoryError: PermGen space` 的问题；类元数据的生命周期与对应的类加载器一致，卸载类加载器时，其加载的类的元数据会被回收。
- 可能出现的异常：
  - OutOfMemoryError`：
    - **JDK7 及之前：** `OutOfMemoryError: PermGen space`。原因：加载了过多的类（如大量使用动态代理、反射、CGLib/Javassist 字节码生成框架）；存在大量不会被回收的类（如应用服务器频繁热部署）；`PermSize/MaxPermSize` 设置过小。
    - **JDK8 及之后：** `OutOfMemoryError: Metaspace`。原因：加载了**极其大量的类**；动态生成（如字节码增强框架）了**极其大量的类**；`MaxMetaspaceSize` 设置过小（或未设置上限但本地内存耗尽）。虽然元空间垃圾回收更有效，但极端情况下仍可能溢出。

**总结与关系：**

- **线程私有区域：** 程序计数器、Java 虚拟机栈、本地方法栈。生命周期与所属线程相同，随线程创建而创建，随线程结束而销毁。**无需考虑垃圾回收问题**。
- **线程共享区域：** Java 堆、方法区/元空间。生命周期与 JVM 进程相同。是**垃圾回收器管理的主要区域**。
- 异常侧重点：
  - **`StackOverflowError`：** 主要由虚拟机栈和本地方法栈深度过大引起（递归过深）。
  - OutOfMemoryError`：
    - **堆空间不足：** 最常见，对象实例过多或堆设置过小。
    - **创建线程栈空间不足：** 线程数过多或每个线程栈设置过大 (`-Xss`)。
    - **方法区/元空间不足：** 加载或动态生成了过多的类信息。
  - **程序计数器无异常。**