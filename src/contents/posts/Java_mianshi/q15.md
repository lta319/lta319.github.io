---
title: 创建复合索引时，字段顺序有什么讲究？什么是“最左前缀原则”？
published: 2025-05-20
description: 创建复合索引时，字段顺序有什么讲究？什么是“最左前缀原则”？
tags: [Markdown, Blogging]
category: Java mianshi
licenseName: "Unlicensed"
author: Ankou
sourceLink: ''
draft: false
---
**你还提到了添加复合索引。创建复合索引时，字段顺序有什么讲究？什么是“最左前缀原则”？**

**1. 复合索引字段顺序的讲究**

创建复合索引 `(col1, col2, col3)` 时，字段的顺序**至关重要**。它直接决定了该索引能在哪些查询条件下被有效利用。选择顺序的依据主要基于以下几点：

1. **等值查询 vs 范围查询：**

   - **优先放置等值查询 (=, IN) 的列：** 等值查询能更精确地缩小扫描范围。如果一个列经常出现在等值查询中，将它放在复合索引的前面通常更好。
   - **范围查询 (>, <, BETWEEN, LIKE) 的列放在后面：** 范围查询会使索引在匹配到该列时就停止使用更后面的列。如果把范围查询的列放在索引前面，后面的等值查询列就无法有效利用了。**范围查询列在索引中的位置越靠后，该索引能被使用的条件组合就越多。**

   **例子：** 假设表 `orders` 有 `customer_id` (经常等值查询), `order_date` (经常范围查询), `status` (经常等值查询)。

   - 索引 `(customer_id, status, order_date)`：能高效用于 `WHERE customer_id = 123 AND status = 'shipped'` (精确匹配前两列) 和 `WHERE customer_id = 123 AND status = 'shipped' AND order_date > '2023-10-01'` (前两列等值，第三列范围)。
   - 索引 `(order_date, customer_id, status)`：虽然能用于 `WHERE order_date > '2023-10-01'` (只用到第一列)，但对于 `WHERE customer_id = 123 AND status = 'shipped'` 这个常见查询，由于缺少索引最左列 `order_date` 的条件，**索引可能完全失效或只能部分利用（取决于优化器，但效率不如第一个索引）**。

2. **列的区分度 (基数 - Cardinality)：**

   - **优先放置高区分度（高基数）的列：** 区分度是指该列不同值的数量。值越唯一（如用户ID、手机号），区分度越高；值越重复（如性别、状态标志），区分度越低。
   - **高区分度列放前面能更快过滤数据：** 索引树在查找时，高区分度列能迅速缩小需要扫描的索引条目数量。低区分度列放前面可能扫描大量相同值的索引条目，效果不佳。
   - **与等值/范围结合考虑：** 区分度优先原则通常也服务于等值查询优先原则，因为高区分度列更适合等值查询。

   **例子：** 假设表 `users` 有 `country_code` (低区分度，比如只有几十个值), `city` (中区分度), `last_name` (高区分度)。

   - 查询`WHERE country_code = 'US' AND city = 'New York' AND last_name = 'Smith'`：
     - 索引 `(last_name, city, country_code)`：虽然 `last_name` 区分度最高，但查询条件中最左是 `country_code`。**索引失效或低效！**
     - 索引 `(country_code, city, last_name)`：符合最左前缀，但 `country_code` 区分度低，可能扫描大量属于 `US` 的索引条目，然后过滤 `city` 和 `last_name`。效率尚可，但不是最优。
     - 索引 `(city, last_name, country_code)`：`city` 区分度中等，能较快缩小范围，再结合 `last_name` 高区分度精确定位。对于这个查询，**可能比第二个索引效率更高**。如果业务中经常按 `city` 查询，这个索引也适用。
   - **权衡：** 实际设计中，需要结合查询频率和区分度。如果 `country_code` 条件几乎总是存在，把它放最左保证索引能被用上是基础，即使区分度低。如果 `country_code` 不是总是存在，考虑把高区分度高频率的等值列放前面。

3. **查询频率和覆盖索引：**

   - **高频查询条件涉及的列优先放前面：** 确保最常用的查询能最有效地利用索引。
   - **考虑覆盖索引：** 如果某个高频查询只查询索引中包含的列 (`SELECT col1, col2 FROM table WHERE ...`)，那么该查询可以**完全在索引中完成（Index-Only Scan）**，避免回表（访问聚集索引/数据行），性能极高。将查询中 `SELECT` 的列也包含在复合索引的后面（即使它们不在 `WHERE` 中），可以创建覆盖索引，但这会增加索引大小。**覆盖索引是性能优化的利器。**

**2. 什么是“最左前缀原则” (Leftmost Prefix Rule)**

**最左前缀原则** 是复合索引能被有效使用的**核心规则**。它定义了查询条件如何使用复合索引的部分列。

- **定义：** 对于复合索引 `(col1, col2, col3, ...)`，查询优化器可以利用该索引，**当且仅当查询条件中包含了索引定义中从左开始的、连续的、一个或多个列**。

- **关键点：**

  1. **必须从最左列开始：** 查询条件中必须包含索引定义的第一列 (`col1`)。
  2. **可以连续使用前面的列：** 查询条件可以只包含 `col1`；或者包含 `col1` 和 `col2`；或者包含 `col1`, `col2`, `col3`；以此类推。
  3. **不能跳过前面的列：** 如果查询条件包含 `col2` 和 `col3`，但**不包含** `col1`，那么索引 `(col1, col2, col3)` **将完全失效（无法使用）**，或者只能使用索引的一部分（取决于数据库优化器，但通常效率很低或不被使用）。
  4. **顺序相对灵活：** 查询条件中列的顺序不一定要和索引中定义的顺序完全一致（例如 `WHERE col2 = ? AND col1 = ?`），只要查询条件中**实际包含**了这些列（并且是等值查询），优化器通常能调整顺序来匹配索引的最左前缀。但是，**缺失最左列 (`col1`) 是绝对不允许的。**

- **原理：** 复合索引的构建方式是：首先按第一列 (`col1`) 排序，在第一列值相同的情况下，再按第二列 (`col2`) 排序，以此类推。索引树的结构就是按照这个顺序组织的。因此，只有从最左列开始提供查询条件，数据库才能利用索引的有序性进行高效的查找（二分查找或范围扫描）。跳过最左列，数据库就无法定位索引树的起始位置。

- **举例 (索引 `(last_name, first_name, age)`):**

  | 查询条件                                                     | 能否使用索引 `(last_name, first_name, age)`？ | 使用了索引的哪些部分？                            | 原因                                                         |
  | :----------------------------------------------------------- | :-------------------------------------------- | :------------------------------------------------ | :----------------------------------------------------------- |
  | `WHERE last_name = 'Smith'`                                  | ✅ 是                                          | `last_name`                                       | 使用了索引最左列。                                           |
  | `WHERE last_name = 'Smith' AND first_name = 'John'`          | ✅ 是                                          | `last_name, first_name`                           | 使用了索引最左的两列。                                       |
  | `WHERE last_name = 'Smith' AND first_name = 'John' AND age = 30` | ✅ 是                                          | `last_name, first_name, age`                      | 使用了索引的所有列。                                         |
  | `WHERE first_name = 'John' AND last_name = 'Smith'`          | ✅ 是                                          | `last_name, first_name`                           | 优化器会调整条件顺序以匹配索引 (`last_name` 和 `first_name` 都是等值)。 |
  | `WHERE last_name = 'Smith' AND age = 30`                     | ⚠️ **部分使用**                                | `last_name`                                       | 只能使用 `last_name`。`age` 条件无法利用索引，需在 `last_name` 过滤后对行进行额外过滤。 |
  | `WHERE first_name = 'John'`                                  | ❌ **不能使用或低效**                          | -                                                 | **缺少最左列 `last_name`。** 索引失效或进行全索引扫描（效率极低）。 |
  | `WHERE first_name = 'John' AND age = 30`                     | ❌ **不能使用或低效**                          | -                                                 | **缺少最左列 `last_name`。**                                 |
  | `WHERE age = 30`                                             | ❌ **不能使用或低效**                          | -                                                 | **缺少最左列 `last_name`。**                                 |
  | `WHERE last_name LIKE 'Sm%' AND first_name = 'John'`         | ✅ 是                                          | `last_name` (范围扫描起点), 然后过滤 `first_name` | 范围查询 `LIKE 'Sm%'` 作用于 `last_name`，匹配到行后检查 `first_name`。`first_name` 列在索引中但未完全高效利用。 |

**总结与最佳实践**

1. **设计复合索引：**
   - **最左前缀是基础：** 确保索引的最左列出现在最频繁、最关键的查询条件中。
   - **等值 > 范围 > 排序：** 优先将等值查询列放在最左，其次是范围查询列，最后是 `ORDER BY`/`GROUP BY` 列（如果索引能覆盖排序则避免 `filesort`）。
   - **区分度考量：** 在满足最左前缀和等值优先的前提下，将高区分度列放在更靠前的位置。
   - **覆盖索引：** 对于仅查询索引列的 `SELECT` 语句，考虑将所需列加入复合索引尾部以避免回表。
   - **避免冗余：** 索引 `(A, B)` 通常能涵盖查询 `(A)` 的需求，不必单独创建 `(A)`。
2. **编写查询：**
   - **遵守最左前缀：** 确保 `WHERE`/`JOIN ON` 条件包含复合索引的最左列（尤其是最左第一列）。
   - **避免对索引列计算/函数：** 会导致索引失效。
   - **明确列类型：** 防止隐式类型转换导致索引失效。
   - **善用 `EXPLAIN`：** 分析 SQL 执行计划，确认索引是否正确使用、是否有效避免了回表和 `filesort`。