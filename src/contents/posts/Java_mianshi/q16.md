---
title: MySQL 中常见的锁有哪些类型（共享锁、排他锁、表锁、行锁、意向锁、间隙锁）？
published: 2025-05-20
description: 什么情况下会发生死锁？如何避免和排查死锁？
tags: [Markdown, Blogging]
category: Java mianshi
licenseName: "Unlicensed"
author: Ankou
sourceLink: ''
draft: false
---
**你提到了对锁机制的理解。MySQL 中常见的锁有哪些类型（共享锁、排他锁、表锁、行锁、意向锁、间隙锁）？什么情况下会发生死锁？如何避免和排查死锁？**

**MySQL InnoDB 中常见的锁类型**

MySQL InnoDB 的锁机制复杂且精细，支持多粒度锁，主要包括以下几种类型：

1. **共享锁 (Shared Lock / S Lock / 读锁):**

   - **目的：** 允许事务读取一行数据。
   - **兼容性：** 多个事务可以同时持有同一行数据的 S 锁（允许并发读）。
   - **排斥性：** 如果某个事务持有某行的 S 锁，其他事务**不能**获得该行的 X 锁（排他锁）。
   - **加锁方式：** `SELECT ... LOCK IN SHARE MODE;`

2. **排他锁 (Exclusive Lock / X Lock / 写锁):**

   - **目的：** 允许事务更新或删除一行数据。
   - **兼容性：** 如果一个事务持有某行的 X 锁，**任何其他事务都不能获得该行的 S 锁或 X 锁**。X 锁是排他的。
   - **加锁方式：** `SELECT ... FOR UPDATE;`, `UPDATE`, `DELETE`, `INSERT` (对插入的索引记录隐式加 X 锁)。

3. **表锁 (Table Locks):**

   - **粒度：** 锁定整张表。
   - 类型：
     - **表级共享锁 (S):** 与 `LOCK TABLES ... READ` 相关，兼容其他读锁，排斥写锁。
     - **表级排他锁 (X):** 与 `LOCK TABLES ... WRITE` 相关，排斥所有其他锁。
     - **意向锁 (Intention Locks - 见下):** 是特殊的表级锁。
   - **特点：** 实现简单，开销小，但**并发度最低**。InnoDB 通常优先使用更细粒度的行锁。显式使用 `LOCK TABLES` 会请求表锁。DDL 操作（如 `ALTER TABLE`）通常需要元数据锁（MDL），类似于表锁。

4. **行锁 (Record Locks / Row-Level Locks):**

   - **粒度：** 锁定索引中的**一条具体记录**。
   - **实现：** InnoDB 的行锁是加在**索引记录**上的。即使表没有定义索引，InnoDB 也会创建一个隐藏的聚簇索引（通常是主键或内部生成的 ROWID）并在其上施加行锁。
   - **类型：** 行锁本身可以是 S 锁或 X 锁。
   - **特点：** **并发度高**，是 InnoDB 支持高并发事务的核心机制。但管理开销比表锁大。

5. **意向锁 (Intention Locks):**

   - **目的：** **表级锁**，用于**表示一个事务稍后打算在表中的某些行上施加哪种类型的锁（S 或 X）**。它们是为了在表级锁和行级锁共存时，**快速判断表级锁请求是否与当前行锁冲突**，避免逐行检查锁状态。

   - 类型：

     - **意向共享锁 (Intention Shared Lock - IS):** 表示事务打算在表中的某些行上加 S 锁。`SELECT ... LOCK IN SHARE MODE` 会先加 IS 锁。
     - **意向排他锁 (Intention Exclusive Lock - IX):** 表示事务打算在表中的某些行上加 X 锁。`SELECT ... FOR UPDATE`, `UPDATE`, `DELETE` 会先加 IX 锁。

   - 兼容性：

     |              |  X   |    IX    |  S   |    IS    |
     | :----------: | :--: | :------: | :--: | :------: |
     | **X (表级)** | 冲突 |   冲突   | 冲突 |   冲突   |
     |    **IX**    | 冲突 | **兼容** | 冲突 | **兼容** |
     | **S (表级)** | 冲突 |   冲突   | 兼容 |   兼容   |
     |    **IS**    | 冲突 | **兼容** | 兼容 |   兼容   |

   - **关键点：** 意向锁之间（IX 和 IX, IX 和 IS, IS 和 IS）是兼容的（因为它们只是“意向”），但它们与表级 S 锁和 X 锁不兼容（表级锁需要独占或阻止写）。

6. **间隙锁 (Gap Locks):**

   - **目的：** **锁定索引记录之间的“间隙”**（两个索引值之间的范围），或者锁定第一个索引记录之前或最后一个索引记录之后的范围。
   - **作用：** **防止其他事务在锁定的范围内插入新的记录**，从而**解决幻读问题 (Phantom Read)**。是 RR（可重复读）隔离级别特有的。
   - 特点：
     - 间隙锁可以同时被多个事务持有（共享间隙锁），因为它们都只是防止插入。
     - 间隙锁只对 `INSERT` 操作有效（阻止插入），不影响其他事务在同一个间隙上再加间隙锁或在该间隙内的已存在记录上加记录锁。
     - 在唯一索引（包括主键）的等值查询（`WHERE id = ?`）如果查询的记录存在，只会加记录锁；如果记录不存在，会在“应该出现”的位置加间隙锁。

7. **临键锁 (Next-Key Locks):**

   - **本质：** **记录锁 (Record Lock) + 间隙锁 (Gap Lock)** 的组合。它锁定一个索引记录及其**之前的间隙**。例如，索引包含值 10, 11, 13, 20，那么临键锁可能锁定的区间有：`(-∞, 10]`, `(10, 11]`, `(11, 13]`, `(13, 20]`, `(20, +∞)`。
   - **目的：** InnoDB 在 **RR 隔离级别下，默认的行锁就是临键锁**。这是它解决幻读问题的主要手段。
   - **加锁范围：** 当使用范围条件查询（`WHERE id > 5 AND id < 15`）或非唯一索引的等值查询时，InnoDB 会加临键锁，锁定扫描到的索引记录以及这些记录之前的间隙。
   - **作用：** 确保在此范围内不能插入新数据（防止幻读），同时也锁定已存在的记录。

### 什么情况下会发生死锁？

死锁是指**两个或两个以上的事务在执行过程中，因争夺资源而造成的一种互相等待的现象**，若无外力干涉（如数据库死锁检测和回滚），它们都将无法进行下去。

**死锁产生的四个必要条件（缺一不可）：**

1. **互斥条件 (Mutual Exclusion):** 资源（如行锁）只能被一个事务占有，其他事务请求该资源时只能等待。
2. **请求与保持条件 (Hold and Wait):** 一个事务在持有至少一个资源锁的同时，又请求获取另一个事务持有的资源锁。
3. **不剥夺条件 (No Preemption):** 事务已获得的资源锁在完成前不能被强行剥夺，只能由持有者主动释放。
4. **循环等待条件 (Circular Wait):** 存在一个事务等待序列：T1 等待 T2 占有的资源，T2 等待 T3 占有的资源，……，Tn 等待 T1 占有的资源，形成一个等待环。

**MySQL InnoDB 中的典型死锁场景：**

1. **不同顺序加锁：** 这是最常见的死锁原因。
   - 例子：
     - 事务 A：`UPDATE table SET ... WHERE id = 1;` (获得 id=1 的 X 锁) -> `UPDATE table SET ... WHERE id = 2;` (尝试获得 id=2 的 X 锁，等待)
     - 事务 B：`UPDATE table SET ... WHERE id = 2;` (获得 id=2 的 X 锁) -> `UPDATE table SET ... WHERE id = 1;` (尝试获得 id=1 的 X 锁，等待)
   - **结果：** A 持有 id=1 锁并等待 id=2，B 持有 id=2 锁并等待 id=1，形成循环等待。
2. **间隙锁/临键锁冲突：**
   - 例子：在 RR 级别下。
     - 事务 A：`SELECT * FROM table WHERE id > 100 FOR UPDATE;` (对 id>100 的范围加了临键锁或间隙锁)
     - 事务 B：`INSERT INTO table (id, ...) VALUES (150, ...);` (尝试在 id=150 处插入，需要获得插入意向锁，但被 A 的间隙锁阻塞，等待)
     - 此时，如果事务 A 执行一个操作需要锁住事务 B 正在等待插入的间隙（比如另一个查询也尝试在 id=150 附近插入或扫描），或者事务 B 在等待过程中又持有 A 需要的其他锁，就可能形成死锁。
3. **唯一键冲突：**
   - 例子：两个事务同时插入相同的主键值。
     - 事务 A：`INSERT INTO table (id, ...) VALUES (10, ...);` (成功插入，获得 id=10 的 X 锁)
     - 事务 B：`INSERT INTO table (id, ...) VALUES (10, ...);` (尝试插入 id=10，需要获得锁，但被 A 阻塞，等待)
     - 如果此时事务 A 执行一个操作需要事务 B 持有的其他锁（或者 A 回滚/提交前又触发了其他锁请求与 B 冲突），也可能死锁。

**如何避免和排查死锁？**

**避免死锁的策略：**

1. **保持一致的访问顺序：** **最重要、最有效的方法！** 在应用程序层面，确保所有事务**以相同的全局顺序访问数据行或表**（例如，总是先按 id 升序处理数据）。这从根本上消除了循环等待的可能性。
2. **尽可能缩小事务范围：** 让事务保持简短，尽快提交或回滚。避免在一个事务中执行大量操作或长时间持有锁。将大事务拆分成小事务。
3. **合理使用索引：** 确保 WHERE 条件有效利用索引。良好的索引可以减少需要锁定的记录数量（减少锁冲突）和扫描范围（减少间隙锁范围）。特别要注意避免全表扫描，这可能导致锁住整个表或大量行。
4. 降低隔离级别： 如果业务允许，考虑将隔离级别从 RR (Repeatable Read) 降低到 RC (Read Committed)。在 RC 级别下：
   - InnoDB 通常会**放弃使用间隙锁 (Gap Locks)** 和 **临键锁 (Next-Key Locks)**（只使用记录锁 Record Locks）。
   - 这大大减少了发生死锁的场景（特别是间隙锁相关的死锁）。
   - **代价：** 可能会出现幻读 (Phantom Read) 和不可重复读 (Non-repeatable Read)。
5. **避免长时间持有锁：** 不要在事务中执行耗时的操作（如网络调用、复杂计算）后再去访问数据库。先获取数据，再执行耗时操作，然后尽快提交事务。
6. **使用 `SELECT ... FOR UPDATE` / `LOCK IN SHARE MODE` 时谨慎：** 只在必要时使用显式锁定。明确你需要的是读锁还是写锁。
7. **使用乐观锁 (Optimistic Locking)：** 在冲突较少的情况下，可以考虑基于版本号或时间戳的乐观锁机制（如在 `UPDATE` 语句的 `WHERE` 子句中检查版本号），避免使用数据库的悲观锁机制。这完全避免了数据库层面的锁竞争和死锁风险。

**排查死锁：**

1. 查看最近死锁信息：使用命令：

   ```sql
   SHOW ENGINE INNODB STATUS\G
   ```

   - 在输出结果中找到 **`LATEST DETECTED DEADLOCK`** 部分。这是最近一次死锁的详细信息。
   - 关键内容：
     - `*** (1) TRANSACTION:` / `*** (2) TRANSACTION:`： 参与死锁的两个事务的信息（事务ID, 状态）。
     - `*** (1) WAITING FOR THIS LOCK TO BE GRANTED:` / `*** (2) HOLDS THE LOCK(S):` / `*** (2) WAITING FOR THIS LOCK TO BE GRANTED:`： **最核心部分！** 清晰地展示了事务1在等待什么锁（哪个表、哪个索引、哪个记录/间隙、什么类型的锁），事务2当前持有哪些锁以及它在等待什么锁。这明确揭示了死锁的循环等待链。
     - `*** WE ROLL BACK TRANSACTION (1) [or (2)]`： InnoDB 选择了回滚哪个事务来打破死锁（通常选择回滚代价较小的事务）。

2. 开启死锁日志记录 (MySQL 5.6.3+):设置全局参数：

   ```sql
   SET GLOBAL innodb_print_all_deadlocks = ON;
   ```

   - 此设置会**将所有死锁信息记录到 MySQL 的错误日志 (Error Log)** 中，方便后续分析频繁发生的死锁问题。

3. 分析死锁信息：

   - 仔细阅读 `SHOW ENGINE INNODB STATUS` 或错误日志中的死锁报告。
   - 重点理解：**每个事务在做什么操作？** (`SQL` 语句) **它持有哪些锁？** (`HOLDS THE LOCK(S)`) **它在等待哪个锁？** (`WAITING FOR THIS LOCK`)。找出循环等待的点。
   - 结合应用程序代码，分析为什么会出现这种锁等待顺序（不一致的访问顺序？）。

4. **工具辅助：** 可以使用 Percona Toolkit 中的 `pt-deadlock-logger` 等工具持续监控和分析死锁信息。

**总结：**

理解 MySQL InnoDB 的锁类型（特别是行锁、间隙锁、临键锁、意向锁）是分析并发问题和死锁的基础。死锁的核心原因是**事务以不同顺序请求锁**，形成了一个**循环等待链**。**避免死锁最有效的方法是确保所有事务以一致的顺序访问数据**。其他策略包括保持事务短小、使用合适的索引、考虑降低隔离级别（RC）等。当死锁发生时，利用 `SHOW ENGINE INNODB STATUS` 和错误日志进行深入排查，找出根本原因并修复应用程序逻辑或数据库设计。数据库的死锁检测机制会自动选择一个受害者事务回滚来解开死锁。