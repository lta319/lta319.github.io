---
title: 类加载机制
published: 2025-05-01
description: 类加载机制
tags: [Markdown, Blogging]
category: Java mianshi
licenseName: "Unlicensed"
author: Ankou
sourceLink: ''
draft: false
---
类加载机制包含哪些阶段（加载、验证、准备、解析、初始化）？什么是双亲委派模型？它的作用是什么？打破双亲委派模型有哪些场景？

类加载机制是 Java 运行时的核心基础之一，它负责将 `.class` 文件加载到 JVM 内存中，转换成可以被执行的 Java 类型（Class）。这个过程非常严谨，分为几个明确的阶段。

**一、类加载机制的阶段 (生命周期)**

类加载过程主要包含以下 5 个阶段：

1. **加载 (Loading)**
   - **任务：** 查找并加载类的二进制字节流（`.class` 文件）。
   - 过程：
     - 通过类的**全限定名**（Fully Qualified Name）获取其定义的二进制字节流（可以从 ZIP/JAR/WAR包、网络、运行时计算生成（如动态代理）、数据库、加密文件等获取）。
     - 将这个字节流所代表的静态存储结构转化为**方法区**（JDK7 及之前）/ **元空间**（JDK8+）的运行时数据结构。
     - 在内存（堆）中创建一个代表这个类的 `java.lang.Class` 对象，作为方法区/元空间中该类各种数据的访问入口。
   - **关键点：** 由**类加载器 (ClassLoader)** 完成。数组类由 JVM 直接创建，不通过类加载器，但其元素类型最终仍由类加载器加载。
2. **验证 (Verification)**
   - **任务：** 确保被加载的类的字节流符合《Java虚拟机规范》的约束要求，保证其不会危害虚拟机自身安全。
   - 检查内容：
     - **文件格式验证：** 验证字节流是否符合 Class 文件格式规范（魔数、版本号、常量池类型等）。
     - **元数据验证：** 对类的元数据信息进行语义校验（是否有父类、是否继承了 final 类、非抽象类是否实现了所有抽象方法、字段/方法是否与父类冲突等）。
     - **字节码验证：** 通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的（操作数栈类型匹配、跳转指令目标合理、类型转换有效等）。
     - **符号引用验证：** 发生在“解析”阶段，检查符号引用能否转化为直接引用（能否找到对应的类、字段、方法，访问权限是否合法等）。发生在虚拟机将符号引用解析为直接引用的时候。
   - **重要性：** 是保护虚拟机安全的重要屏障。虽然可以通过 `-Xverify:none` 或 `-noverify` 参数关闭大部分验证，但不推荐。
3. **准备 (Preparation)**
   - **任务：** 为类中定义的**静态变量 (static 变量)** 分配内存并设置**默认初始值 (零值)**。
   - 关键点：
     - 分配的内存在**方法区/元空间**。
     - 此时设置的是数据类型的**零值**，例如 `int` 为 0, `long` 为 0L, `boolean` 为 false, `reference` 为 null 等。
     - **常量 (`static final`)** 如果被 `ConstantValue` 属性标记（基本类型或 String 字面量），在准备阶段就会被直接初始化为指定的值。其他静态变量（包括 `static final` 但非基本类型/字面量的常量）的赋值操作在 **初始化** 阶段进行。
     - 类变量（静态变量）的赋值操作和静态代码块（`static {}`）的执行都在 **初始化** 阶段。
4. **解析 (Resolution)**
   - **任务：** 将常量池内的**符号引用 (Symbolic References)** 替换为**直接引用 (Direct References)** 的过程。
   - **符号引用：** 一组符号来描述所引用的目标（如类和接口的全限定名、字段的名称和描述符、方法的名称和描述符）。与虚拟机内存布局无关。
   - **直接引用：** 直接指向目标的指针、相对偏移量或能间接定位到目标的句柄。和虚拟机的内存布局相关。
   - **解析目标：** 主要解析类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这 7 类符号引用。
   - **时机：** 《Java虚拟机规范》允许在类加载器加载类时就解析，也允许等到符号引用被首次使用时（在执行特定字节码指令如 `anewarray`, `checkcast`, `getfield`, `getstatic`, `instanceof`, `invokeinterface`, `invokespecial`, `invokestatic`, `invokevirtual`, `ldc`, `ldc_w`, `multianewarray`, `new`, `putfield`, `putstatic`）才去解析（称为“延迟解析”或“惰性解析”）。HotSpot 虚拟机主要采用**惰性解析**。
5. **初始化 (Initialization)**
   - **任务：** 执行类的初始化方法 `<clinit>()`。
   - `<clinit>()` 方法：
     - 由编译器自动收集类中**所有类变量的赋值动作（`static` 变量显式赋值）和静态语句块（`static {}` 块）中的语句**合并产生。顺序由源文件顺序决定。
     - 如果类没有静态变量赋值或静态语句块，编译器可以不生成 `<clinit>()`。
     - 父类的 `<clinit>()` 先于子类的执行。
     - 接口中不能使用静态语句块，但可以有静态变量赋值。执行接口的 `<clinit>()` 不需要先执行父接口的（除非父接口定义的变量被使用）。接口的实现类在初始化时也不会执行接口的 `<clinit>()`。
     - 虚拟机保证一个类的 `<clinit>()` 方法在多线程环境中被正确地**加锁同步**（隐式锁），只会被一个线程执行一次。
   - 触发时机（有且仅有以下 6 种）：
     1. 遇到 `new`, `getstatic`, `putstatic`, `invokestatic` 这 4 条字节码指令时（对应场景：创建实例、读取/设置静态字段（非常量）、调用静态方法）。
     2. 使用 `java.lang.reflect` 包的方法对类进行**反射调用**时。
     3. 当初始化一个类时，发现其父类还未初始化，需先触发其父类的初始化。
     4. 虚拟机启动时，用户指定的包含 `main()` 方法的主类。
     5. 使用 JDK7+ 的动态语言支持时，如果一个 `java.lang.invoke.MethodHandle` 实例最后的解析结果为 `REF_getStatic`, `REF_putStatic`, `REF_invokeStatic`, `REF_newInvokeSpecial` 四种句柄时，该句柄对应的类需要先初始化。
     6. 当一个接口定义了 JDK8 新加入的默认方法（`default` 方法）时，如果有该接口的实现类发生初始化，那么该接口要在其之前被初始化。

**二、双亲委派模型 (Parent Delegation Model)**

1. **是什么？**

   - 这是 Java 设计团队推荐的一种**类加载器之间的协作关系模型**，而非强制约束。

   - 该模型要求除了顶层的**启动类加载器 (Bootstrap ClassLoader)** 外，其余的类加载器都应有自己的**父类加载器 (Parent ClassLoader)**。这里的父子关系一般通过**组合 (Composition)** 而非继承来实现。

   - 类加载器之间的层次关系：

     ```
     [ 启动类加载器 (Bootstrap ClassLoader) ]
                  ^
                  |
     [ 扩展类加载器 (Extension ClassLoader) ]
                  ^
                  |
     [ 应用程序类加载器/系统类加载器 (Application/System ClassLoader) ]
                  ^
                  |
     [ 自定义类加载器 (User-Defined ClassLoader) 1 ]
     [ 自定义类加载器 (User-Defined ClassLoader) 2 ]
     ... ...
     ```

2. **工作流程 (双亲委派)：**
   当一个类加载器收到类加载请求时，它首先​**​不会自己去尝试加载​**​这个类，而是把这个请求​**​委派给父类加载器​**​去完成。每一层的类加载器都是如此。因此，所有的加载请求最终都应该传送到顶层的​**​启动类加载器​**​。

   - 只有当**父类加载器反馈自己无法完成这个加载请求**（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。
   - 简单说：“先问爸爸，爸爸不行我再自己来”。

3. **作用 (为什么重要？)：**

   - **保证核心类库的安全性和唯一性：** 防止用户编写一个同名（如 `java.lang.Object`）的恶意类被加载，从而篡改核心 API 的行为。核心类库始终由启动类加载器加载，用户自定义的类加载器无法加载（因为父加载器能加载到）。
   - **避免类的重复加载：** 确保一个类在 JVM 的各种类加载器环境中是**同一个类**（由加载它的类加载器和类全限定名共同标识）。父加载器加载过的类，子加载器不会再去加载（如果父加载器能加载到）。这保证了 Java 类型体系中最基础的类型一致性（如 `Object.class` 在内存中只有一份）。
   - **保证了加载的有序性：** 按照从父到子的顺序加载，确保了基础类的加载优先于应用类。

**三、打破双亲委派模型的场景**

虽然双亲委派是推荐模型，但在某些特定场景下，需要或必须打破它：

1. **SPI (Service Provider Interface) 服务发现机制 (如 JDBC)：**
   - **问题：** Java 核心库（如 `java.sql.Driver`）由 `Bootstrap ClassLoader` 加载。数据库厂商实现的驱动（如 `com.mysql.cj.jdbc.Driver`）通常放在应用 `classpath` 下，应由 `AppClassLoader` 加载。但根据双亲委派，`AppClassLoader` 会委派给父加载器（`Extension` -> `Bootstrap`），但 `Bootstrap` 无法加载应用 `classpath` 下的类。
   - **打破方式：** 使用**线程上下文类加载器 (Thread Context ClassLoader, TCCL)**。核心代码（如 `DriverManager`）在运行时，通过 `Thread.currentThread().getContextClassLoader()` 获取到通常由应用设置的上下文类加载器（默认是 `AppClassLoader`），然后用这个类加载器去加载 SPI 实现类。这相当于**父类加载器（核心库加载器）请求子类加载器（`AppClassLoader`）去加载类**，打破了自下而上的委派链。**（逆向委派）**
2. **热部署、热替换、模块化 (如 OSGi, JBoss Modules)：**
   - **需求：** 需要实现同一个类的不同版本共存、动态加载/卸载模块。
   - **打破方式：** 这些框架实现了自己复杂的类加载器体系。每个模块（Bundle）有自己的类加载器。类加载请求在模块内部优先处理（如检查模块内部的 `Import-Package` 依赖是否满足），只有在找不到或明确需要委托时，才会按照特定的规则（如 OSGi 的 `Import-Package` 指向的 Bundle）进行委派。它不是简单的父->子关系，而是一个**网状的委派结构**。同一个类由不同的加载器加载，就能在 JVM 中共存多个版本。这完全打破了双亲委派的层次结构和唯一性保证。
3. **Tomcat / Jetty 等 Web 容器：**
   - **需求：** 隔离不同 Web 应用（防止应用类冲突、独立卸载应用）、共享某些公共库。
   - 打破方式：
     - 每个 Web 应用通常有一个独立的 `WebappClassLoader`。
     - `WebappClassLoader` 在加载自己应用路径 (`WEB-INF/classes`, `WEB-INF/lib`) 下的类时，会**优先自己尝试加载**（而不是先委派给父加载器 `SharedClassLoader`），加载不到才委派。这保证了应用的独立性。**（先自己，再委派）**
     - 公共库（如 Servlet API）由 `SharedClassLoader` 加载，所有 `WebappClassLoader` 都会委派给它。这实现了共享。
     - 容器自身的类由另一个加载器加载（如 `CatalinaClassLoader`），与应用类加载器隔离。
     - 这打破了双亲委派的自下而上顺序，实现了隔离与共享的平衡。
4. **用户自定义类加载器的需求：**
   - 如果用户需要实现一些特殊逻辑（如从特定加密文件中加载类、动态生成类字节码），可能会覆盖 `loadClass()` 方法（实现双亲委派逻辑的地方）或 `findClass()` 方法（建议覆盖的地方，由 `loadClass()` 调用），在其中实现自定义的加载逻辑，可能绕过部分委派。覆盖 `loadClass()` 需要小心维护委托关系，否则容易破坏安全性。
5. **JDK 9+ 模块化系统 (Jigsaw)：**
   - **改变：** Jigsaw 引入了新的类加载机制来支持模块。
   - 打破点：虽然底层委托逻辑仍在，但委派规则更加复杂：
     - 模块有其依赖关系。
     - 类加载基于模块路径 (`--module-path`) 而非类路径 (`-classpath`/`-cp`)。
     - 类加载器（如 `BootLayer`）在加载类时，会根据模块的依赖关系（`requires`）来查找，优先在同一个模块或依赖模块中查找。这不再是简单的父->子层次结构委托，而是基于模块图的委托。
     - 它重新定义和约束了类加载器的行为，可以看作是对双亲委派模型的一种现代化演进和部分“打破”（尤其是对路径查找规则的改变）。

**总结：**

- **类加载 5 阶段：** 加载 -> 验证 -> 准备 -> 解析 -> 初始化。其中准备阶段设置零值，初始化阶段执行 `<clinit>`。
- **双亲委派模型：** 核心类加载器层次（Bootstrap -> Extension -> Application）和“父优先”的委派加载规则。**作用：安全（核心库唯一）、避免重复加载、保证基础类优先。**
- 打破场景：
  - **SPI (JDBC等)：** 使用 **TCCL 逆向委派** (父让子加载)。
  - **热部署/模块化 (OSGi等)：** **网状委派**，允许同名类共存。
  - **Web容器 (Tomcat等)：** **优先自加载 + 分层共享** (保证应用隔离)。
  - **用户自定义：** 覆盖加载方法实现特定逻辑。
  - **JDK9+ 模块化：** **基于模块依赖图的委托**，重构了加载规则。