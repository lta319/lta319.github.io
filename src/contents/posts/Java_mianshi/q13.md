---
title: 索引为什么能提高查询速度？B+树索引的结构特点是什么？聚集索引和非聚集索引（二级索引）的区别是什么？什么情况下索引会失效？
published: 2025-05-01
description: 索引为什么能提高查询速度？B+树索引的结构特点是什么？聚集索引和非聚集索引（二级索引）的区别是什么？什么情况下索引会失效？
tags: [Markdown, Blogging]
category: Java mianshi
licenseName: "Unlicensed"
author: Ankou
sourceLink: ''
draft: false
---
**索引为什么能提高查询速度？B+树索引的结构特点是什么？聚集索引和非聚集索引（二级索引）的区别是什么？什么情况下索引会失效？**

**1. 索引为什么能提高查询速度？**

想象一下在一本没有目录的厚重电话簿中查找某个人的电话号码。你需要逐页扫描，直到找到为止。这就像数据库的**全表扫描 (Full Table Scan)**，时间复杂度是 `O(n)`，当数据量巨大时，性能会急剧下降。

索引的作用就像为这本电话簿创建了一个**按姓名排序的目录**。这个目录告诉你目标姓名大概在哪一页。通过查询目录（索引），你可以**快速定位**到目标数据所在的**物理位置（或近似位置）**，然后直接去那里读取数据，避免了扫描整本书。

**技术本质：**

- **减少磁盘 I/O 次数：** 数据库的数据存储在磁盘上，磁盘 I/O 是数据库操作中最慢的环节。索引是一种**独立的数据结构**（如 B+Tree），它通常比完整的数据行小得多，可以更快地加载到内存中。
- **高效的数据组织：** 索引以一种**有序的、利于快速查找（如二分查找）** 的方式存储表中**特定列（或列组合）的值**以及指向该值对应**数据行位置（如主键值或数据行的物理地址）的指针**。
- **避免全表扫描：** 查询优化器分析查询条件和可用索引。如果存在合适的索引，它会优先选择使用索引来定位满足条件的少量数据行，而不是读取整张表的所有数据。

**因此，索引的核心价值在于：它通过额外的小型数据结构，为数据库引擎提供了一种高效定位数据的路径，从而将查找数据的时间复杂度从 `O(n)` 降低到接近 `O(log n)`（对于树型索引）。**

**2. B+树索引的结构特点（InnoDB 的默认索引）**

B+Tree 是目前关系型数据库（如 MySQL InnoDB, PostgreSQL）中最常用、最高效的索引数据结构。

**结构特点：**

1. **多叉平衡树：**
   - 树是平衡的（所有叶子节点都在同一层），保证了查找效率的稳定性。
   - 每个节点可以存储多个键值（Key）和指针（Pointer），远多于二叉树。这大大降低了树的高度（H），通常 3-4 层就能支持千万甚至亿级数据。
2. **节点结构：**
   - **非叶子节点（索引节点）：** 只存储**键值 (Key)** 和指向**子节点**的**指针 (Pointer)**。不存储实际的数据行。
   - 叶子节点：
     - 存储**键值 (Key)** 和指向**实际数据行**的**指针 (Pointer)**。
     - 对于 **聚集索引 (Clustered Index)**，叶子节点直接存储**完整的数据行 (Row Data)**。
     - 对于 **非聚集索引 (Non-Clustered Index / Secondary Index)**，叶子节点存储的是该索引列的键值和对应的 **主键值 (Primary Key Value)**。
     - 所有叶子节点之间使用**双向链表**按顺序连接起来。
3. **顺序存储与高效范围查询：**
   - 所有键值在**叶子节点层**是**按顺序存储**的（从左到右递增）。
   - 叶子节点间的**双向链表**使得进行范围查询 (`BETWEEN`, `>`, `<`, `>=`, `<=`) 和 `ORDER BY` 操作极其高效。引擎只需找到范围的起始点，然后沿着链表顺序扫描叶子节点即可，不再需要回溯到上层节点。
4. **更适合磁盘存储：**
   - 节点大小通常设计为与磁盘块/页大小匹配（如 16KB）。一次磁盘 I/O 可以读取一个节点（包含多个键值/指针），充分利用了磁盘的预取能力。
   - 非叶子节点不存数据行，使得单个节点能容纳更多的键值，进一步降低树的高度，减少 I/O 次数。
   - 叶子节点存储实际数据（聚集索引）或主键（非聚集索引），定位数据更快。

**B+Tree vs B-Tree：**
\* B-Tree 的所有节点（包括非叶子节点）都可能存储数据指针。
\* B+Tree 的数据指针​**​只存在于叶子节点​**​，非叶子节点仅为索引。这使得 B+Tree 的非叶子节点更“瘦”，能容纳更多索引项，树更矮，I/O 更少。
\* B+Tree 的叶子节点有链表连接，范围查询性能远超 B-Tree。

**3. 聚集索引 (Clustered Index) vs 非聚集索引 (Non-Clustered Index / Secondary Index)**

这是两种最核心的索引类型，理解它们的区别至关重要。

| 特性                | 聚集索引 (Clustered Index)                                   | 非聚集索引 (Secondary Index)                                 |
| :------------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **定义**            | **表数据本身**按照索引键的顺序物理存储。                     | **独立的数据结构**，存储索引键值和指向数据行的指针。         |
| **数量**            | **每个表有且只有一个**（因为数据行只能按一种方式物理存储）。 | 每个表可以有多个（0个或多个）。                              |
| **叶子节点内容**    | **存储完整的实际数据行 (Row Data)**。                        | 存储**索引键值 + 对应行的主键值 (PK)**。                     |
| **数据行位置**      | 数据行就存储在索引的叶子节点上。                             | 数据行存储在聚集索引（主键索引）的叶子节点上。               |
| **查找过程 (回表)** | 直接通过聚集索引找到数据行。                                 | 1. 在二级索引中找到主键值。 2. 用这个主键值去**聚集索引中查找**完整数据行（称为**回表查询 - Bookmark Lookup**）。 |
| **物理存储顺序**    | **决定**表中数据行的物理存储顺序。                           | **不影响**数据行的物理存储顺序。                             |
| **主键**            | InnoDB 中，主键索引 (PRIMARY KEY) 默认就是聚集索引。如果没定义主键，InnoDB 会选择一个唯一非空索引，或自动生成一个隐藏的 ROWID 作为聚集索引。 | 主键索引之外的索引都是非聚集索引。                           |
| **效率**            | 根据主键查询效率**最高**（直接定位数据行）。                 | 根据索引键查询效率高，但**需要回表**时会有额外开销。         |
| **优点**            | * 主键/范围查询极快。 * 数据访问路径短。                     | * 提供额外的查询路径。 * 创建灵活。                          |
| **缺点**            | * 插入速度受键值顺序影响（可能页分裂）。 * 更新聚集索引键代价高（可能导致行移动）。 | * 查询非索引列或需要完整行时，需要回表。 * 占用额外空间。    |

**简单类比：**

- **聚集索引：** 就像一本按作者姓名排序的书籍。书的内容（数据行）本身就是按照作者姓名（索引键）物理排列的。要找某位作者的书，直接翻到那个位置就能看到内容。
- **非聚集索引：** 就像书后面的主题索引（比如“索引”这个词出现在第10页和第25页）。索引本身是独立的一页（数据结构），它告诉你主题关键词（索引键）对应的页码（主键值）。要找到“索引”这个词的具体内容，你需要先查主题索引得到页码，然后根据页码（主键值）翻到书（聚集索引）中对应的页码位置才能看到实际内容（数据行）。

**4. 什么情况下索引会失效？**

即使创建了索引，查询优化器也可能选择不使用它（或者无法有效使用），导致索引失效。常见原因包括：

1. **未遵循最左前缀原则 (Leftmost Prefix Rule)：**
   - **问题：** 对于**联合索引 (Composite Index / Multi-column Index)** `(col1, col2, col3)`，查询条件必须**包含索引定义中的最左边的列 (`col1`)**，并且最好是连续的，优化器才能有效地使用该索引。
   - 失效例子：
     - `WHERE col2 = 'value' AND col3 = 'value'` (缺少 `col1`)
     - `WHERE col1 LIKE '%value%'` (虽然用了 `col1`，但通配符 `%` 开头导致无法利用索引的有序性)
     - `WHERE col1 = 'value' AND col3 = 'value'` (跳过了 `col2`，索引只能部分利用 `col1`，无法高效使用 `col3`)
2. **在索引列上做了计算、函数或类型转换操作：**
   - **问题：** 索引存储的是列的原始值。如果在 `WHERE` 条件中对索引列进行了操作，数据库就无法直接使用索引的值进行查找。
   - 失效例子：
     - `WHERE YEAR(date_column) = 2023` (对 `date_column` 使用了 `YEAR()` 函数)
     - `WHERE amount * 1.1 > 100` (对 `amount` 做了计算)
     - `WHERE CAST(id AS CHAR) = '100'` (对 `id` 进行了类型转换)
     - `WHERE UPPER(name) = 'JOHN'` (对 `name` 使用了函数)
3. **在索引列上使用 `NOT`, `!=`, `<>` (不等于)：**
   - **问题：** 这些操作通常需要扫描大部分索引（甚至整个索引），成本可能高于全表扫描，优化器可能放弃使用索引。
   - **失效例子：** `WHERE status != 'active'` (如果 `status` 只有少数几个值，且 `'active'` 是少数，索引可能仍有效，但通常效果差)
4. **在索引列上使用 `OR` 连接非索引列条件：**
   - **问题：** 如果 `OR` 的一边是索引列，另一边是**没有索引**的列，数据库通常无法同时有效地使用索引，可能会选择全表扫描。
   - **失效例子：** `WHERE indexed_col = 10 OR non_indexed_col = 20` (如果 `non_indexed_col` 无索引)
   - **注意：** `WHERE indexed_col = 10 OR indexed_col = 20` 这种索引列自身的 `OR` 通常可以利用索引（如类型转换 `index_merge`）。
5. **使用前导通配符的 `LIKE` 模糊查询 (`'%value'`)：**
   - **问题：** 索引按照列值的前缀排序。以 `%` 开头的 `LIKE` 模式使得索引无法利用其有序性。
   - **失效例子：** `WHERE name LIKE '%Smith'`
   - **有效例子：** `WHERE name LIKE 'John%'` (后缀通配符通常能用索引)
6. **索引列包含大量 NULL 值：**
   - **问题：** 如果索引列允许为 NULL 且 NULL 值比例非常高（远超非 NULL 值），优化器可能认为使用索引效率不如全表扫描。
   - **潜在失效：** `WHERE nullable_col IS NULL` (当 NULL 非常多时)
7. **数据分布不均，优化器判断全表扫描更快：**
   - **问题：** 优化器基于统计信息（如基数 Cardinality）估算不同执行计划的成本。如果查询条件匹配表中**绝大多数数据行**（例如 > 20-30%），使用索引（需要大量回表 + 随机 I/O）的成本可能高于顺序扫描整张表（顺序 I/O）。
   - **潜在失效：** 即使查询条件命中了索引，如果 `WHERE indexed_col > 0` (假设 `indexed_col` 总是正数)，优化器可能选择全表扫描。
8. **隐式类型转换：**
   - **问题：** 如果查询条件中的值与索引列的类型不匹配，数据库需要执行隐式类型转换，相当于在列上应用了函数。
   - **失效例子：** 索引列 `phone` 是 `VARCHAR`，但查询写 `WHERE phone = 13800138000` (数字常量)。数据库需要将每一行的 `phone` 字符串转换成数字进行比较，导致索引失效。应写成 `WHERE phone = '13800138000'`。

**如何避免索引失效？**

- **理解最左前缀原则：** 设计联合索引时考虑常用查询顺序。
- **避免对索引列操作：** 将计算、函数处理放到常量或查询的另一侧。
- **谨慎使用 `NOT`, `!=`, `OR`：** 考虑用其他方式重写查询。
- **注意 `LIKE` 写法：** 尽量避免 `%` 开头。
- **保持类型一致：** 确保查询条件的类型与索引列定义的类型一致。
- **分析执行计划：** 使用 `EXPLAIN` 或 `EXPLAIN ANALYZE` 命令查看 SQL 语句的执行计划，确认是否使用了预期的索引以及使用方式（`type` 列显示 `ref`, `range`, `index_merge`, `const` 等通常是好的；`ALL` 表示全表扫描）。根据执行计划分析优化。
- **定期更新统计信息：** 使用 `ANALYZE TABLE` 确保优化器有准确的数据分布信息来做决策。