---
title: 使用了Redis分布式锁来解决并发预约问题。能详细说说你是如何实现这个分布式锁的吗？考虑过锁的过期时间、锁的可重入性、以及可能的死锁问题吗？有没有了解过 Redisson 或其他的分布式锁解决方案？
published: 2025-05-01
description: 使用了Redis分布式锁来解决并发预约问题。能详细说说你是如何实现这个分布式锁的吗？考虑过锁的过期时间、锁的可重入性、以及可能的死锁问题吗？有没有了解过 Redisson 或其他的分布式锁解决方案？
tags: [Markdown, Blogging]
category: Java mianshi
licenseName: "Unlicensed"
author: Ankou
sourceLink: ''
draft: false
---
**在智慧自习室项目中，你使用了Redis分布式锁来解决并发预约问题。能详细说说你是如何实现这个分布式锁的吗？考虑过锁的过期时间、锁的可重入性、以及可能的死锁问题吗？有没有了解过 Redisson 或其他的分布式锁解决方案？**

## 核心实现原理：

SETNX + EXPIRE + Lua 脚本： 我使用了Redis的 SETNX 命令来尝试设置一个代表座位的键（Key）。ey的格式类似于 lock:seat:{seatId}（例如 lock:seat:101）。
	如果 SETNX 返回 1，表示当前没有其他线程持有该座位的锁，当前线程成功获取锁。
	关键点1：原子性设置锁与过期时间： 为了防止在设置锁成功之后、设置过期时间之前服务宕机导致锁永不释放（死锁风险），我使	用Lua脚本将 SETNX 和 EXPIRE 命令封装成一个原子操作：

```lua
if redis.call('setnx', KEYS[1], ARGV[1]) == 1 then
    return redis.call('pexpire', KEYS[1], ARGV[2])
else
    return 0
end
```

## 锁的释放：

GET + DEL + Lua 脚本： 释放锁时，不能简单地执行 DEL 命令，否则可能误删其他线程持有的锁（如果当前线程执行超时，锁自动过期后被其他线程获取）。释放锁也需要保证原子性和安全性：
```lua
if redis.call('get', KEYS[1]) == ARGV[1] then
    return redis.call('del', KEYS[1])
else
    return 0
end
这个脚本先检查锁的值是否等于本线程设置的唯一标识（UUID）。如果匹配，说明锁仍然由本线程持有，此时才执行删除操作。这个Lua脚本保证了检查和删除操作的原子性。
```

## 关键问题的考虑：

### 锁的过期时间：

​	必要性： 这是防止死锁的最重要保障。即使持有锁的线程因为任何原因（如GC停顿、服务崩溃、网络中断）未能主动释放锁，锁也会在设定的过期时间后自动释放，让其他线程有机会获取。
​	设置： 过期时间需要仔细权衡。设置过短，可能导致业务逻辑未执行完锁就释放，引发并发问题（如两个用户同时预约同一个座位）。设置过长，会导致系统在服务故障后恢复变慢（其他线程需等待锁过期）。在我们的场景，根据预约操作的平均耗时（包括数据库操作、库存扣减、状态更新等，大约在100-200ms内），我设置了一个相对保守的过期时间：3秒（3000ms），为业务逻辑留出足够的缓冲空间，同时避免过长的故障恢复等待。
​	挑战：锁续期： 3秒是预估值。如果某个线程的业务逻辑执行时间接近甚至超过3秒（例如数据库响应慢、发生了Full GC），锁可能在业务完成前过期，风险依然存在。这就是“锁续期”问题。
### 锁的可重入性：
​	问题： 在同一个线程内，如果一个持有锁的方法调用了另一个也需要获取同一把锁的方法，会导致死锁（因为Redis锁不支持重入）。
​	考虑： 在智慧自习室项目中，我仔细梳理了预约流程的调用链。预约的核心逻辑是一个相对独立的服务入口，内部没有嵌套获取同一座位锁的场景。 因此，重入性的需求在本项目中不存在。我实现的锁是简单的互斥锁（Mutex Lock）。如果需要实现可重入锁，通常需要在Redis中记录锁的持有者（线程标识）和重入次数，并在释放时递减次数，只在次数为0时真正删除Key。这会使实现更复杂。
### 可能的死锁问题：
​	锁过期失效（上述）： 这是最主要的风险点，通过设置合理的过期时间和Lua脚本保证原子释放来缓解。
​	锁永久持有（不设置过期时间）： 通过强制设置过期时间避免。
​	锁释放错误（非持有者释放）： 通过使用唯一标识（UUID）和Lua脚本检查解决。
​	集群环境下的脑裂问题（主备切换）： 在Redis哨兵或集群模式下，如果主节点发生故障切换，可能会出现锁状态丢失或不一致的情况。这是一个更复杂的问题，需要依赖Redis的部署架构和数据一致性保证级别。在智慧自习室项目中，我们的Redis是单节点部署（项目规模决定），所以暂时没有遇到这个问题。但对于要求更高一致性的生产环境，需要更健壮的方案。

## Redisson 和其他解决方案的了解：

### Redisson：

我在后续学习和优化过程中了解到 Redisson 是一个非常成熟和强大的Java Redis客户端，它内置了完善的分布式锁实现 RLock。
	优点： 它解决了上述大部分痛点：
		锁续期： 通过后台的“看门狗”线程（Watchdog）自动续期，防止业务未完成锁过期。
		可重入： 原生支持。
		高可用： 支持RedLock（多节点独立获取锁，半数以上成功才算获取成功，降低单点故障风险，但有争议），以及基于Redis集群模式的锁。
		丰富的API： 提供了公平锁、联锁、红锁等多种锁类型，开箱即用。
	反思： 如果现在让我重新设计这个系统，或者项目进入更复杂的生产阶段，我会优先选择使用Redisson。它封装了底层复杂性，提供了更高的可靠性和易用性，避免了自己实现可能隐藏的细微Bug（尤其是在续期和高可用方面）。

### 对关键问题的解决 (Redisson的优势):

​	锁的过期时间与自动续期 (看门狗机制 - Watchdog):
​		痛点解决： 这是 Redisson 最大的优势之一。当我们在 tryLock() 方法中将 leaseTime 参数设置为 null 时，Redisson 会启动一个后台守护线程（看门狗）。
​		原理： 看门狗线程默认每隔 锁过期时间 / 3 (默认锁过期时间为 30 秒，所以每 10 秒) 检查一次业务线程是否还持有该锁。
​		动作： 如果业务线程仍然持有锁（即业务逻辑还在执行中），看门狗线程会自动重置锁的过期时间（续期回默认的 30 秒）。
​		优点： 这完美解决了业务执行时间超过锁初始过期时间导致锁意外释放的风险。即使业务处理时间较长（比如遇到数据库慢查询、GC停顿），锁也能持续保持有效，直到业务逻辑主动释放锁或持有锁的 JVM 进程崩溃（锁最终会超时释放）。
​		可靠性： 避免了自研方案中需要预估超时时间不准或手动续期的复杂性和风险。
​	锁的可重入性 (Reentrancy):
​		痛点解决： Redisson 的 RLock 天然支持可重入锁。
​		原理： 它在 Redis 中不仅存储了锁的标识（类似 UUID），还记录了一个计数器（代表重入次数）。当同一个线程（在同一个		JVM 内）多次请求同一个锁时：
​		第一次请求：成功获取锁，计数器设置为 1。
​		第二次请求：发现锁已被自己持有，计数器递增为 2。
​		释放锁时：计数器递减。只有当计数器减到 0 时，才会真正删除 Redis 中的锁 Key。
​		优点： 完全避免了在同一个线程内嵌套调用需要同一把锁的方法时发生的死锁问题。这在设计更复杂的业务逻辑时提供了极大的灵活性。
​	可能的死锁问题:
​		锁释放安全性： lock.unlock() 方法内部同样通过 Lua 脚本保证了只有锁的持有者才能释放锁，并且在释放时会正确处理重入计数。
​		超时释放兜底： 即使持有锁的客户端崩溃（进程挂掉、网络彻底断开），由于锁设置了过期时间（并由看门狗维护），锁最终会自动释放，不会造成永久死锁。
​		集群容错 (可选)： 对于更高要求的场景，Redisson 提供了 RedissonRedLock (红锁，基于多个独立 Redis 实例的多数派锁) 或 RedissonMultiLock (联锁，所有实例都需成功)，以提高在 Redis 集群主从切换（脑裂）场景下的可靠性。不过需要注意红锁算法存在一定的性能和资源开销争议，在大部分单 Redis 主节点或可靠集群的场景下，标准的 RLock 配合看门狗已足够健壮。我们的项目当时是单节点 Redis，标准 RLock 完全适用。

### 其他方案：
​	基于ZooKeeper的锁： 利用ZooKeeper的临时有序节点（Ephemeral Sequential ZNodes）实现。优势是强一致性，天然支持锁释放（会话结束节点删除）。缺点是性能通常不如Redis，且需要维护ZooKeeper集群，复杂度较高。适用于对一致性要求极高的场景。
​	基于数据库的锁（如乐观锁、悲观锁）： 可以利用数据库的行锁或唯一键约束来实现。这在并发量不高或者本身就需要操作数据库的场景下是可行的。但在高并发（如QPS 1850）下，频繁加锁对数据库压力极大，性能会成为瓶颈。我们在智慧自习室中使用了Redis库存扣减和分布式锁，正是为了将压力从数据库转移出来。

## 总结：

​	在智慧自习室项目中，我基于Redis SETNX + EXPIRE 命令，并通过Lua脚本保证了获取锁（设置锁与过期时间原子操作）和释放锁（检查标识原子删除）的原子性。为每个锁设置了合理的过期时间（3秒） 作为兜底策略防止死锁。通过唯一标识（UUID） 确保只有锁的持有者才能释放锁。在项目当时的并发需求和架构下（Redis单节点），这个方案有效地解决了高并发预约时的座位竞争问题，实现了QPS 1850的目标。我也认识到自研方案在锁续期（Watchdog） 和 高可用/脑裂场景 下的不足，并了解 Redisson 等成熟框架提供了更健壮、功能更全面的解决方案，是未来高要求项目的首选。