---
title: 垃圾回收机制
published: 2025-05-11
description: 垃圾回收机制是JVM的核心。请简述一下常见的垃圾回收算法
tags: [Markdown, Blogging]
category: Java mianshi
licenseName: "Unlicensed"
author: Ankou
sourceLink: ''
draft: false
---
**垃圾回收机制是JVM的核心。请简述一下常见的垃圾回收算法（标记-清除、标记-整理、复制）及其优缺点。你了解哪些常见的垃圾收集器（如 Serial, ParNew, CMS, G1, ZGC）？它们的特点是什么？**

**一、常见的垃圾回收算法**

1. **标记-清除算法 (Mark-Sweep)**
   - 过程：
     1. **标记 (Mark)：** 从 GC Roots（包括栈帧中的局部变量表引用的对象、静态变量、常量、JNI引用的对象等）出发，递归遍历所有可达对象，并进行标记。
     2. **清除 (Sweep)：** 遍历整个堆，回收所有**未被标记**的对象所占用的空间。
   - **优点：** 算法简单直接。
   - 缺点：
     - **效率问题：** 标记和清除两个过程的效率都不高（需要遍历整个堆）。
     - **空间问题：** 回收后会产生大量**内存碎片**。碎片过多会导致后续无法为大对象分配连续的内存空间，从而可能触发另一次 GC。
   - **应用：** 通常不单独使用，是其他算法（如标记-整理）的基础。CMS 收集器的老年代回收主要阶段之一。
2. **复制算法 (Copying)**
   - 过程：
     1. **划分：** 将可用内存划分为大小相等的两块（From Space 和 To Space）。
     2. **分配：** 每次只使用其中一块（From Space）。
     3. **GC：** 当 From Space 满了，触发 GC。将 From Space 中所有**存活**的对象**复制**到 To Space 中，并保持它们的内存连续性。
     4. **清理：** 一次性清理掉整个 From Space。
     5. **交换：** 交换 From Space 和 To Space 的角色（下次 GC 时，现在的 To Space 变成新的 From Space）。
   - 优点：
     - **效率高：** 只复制存活对象，在对象存活率低（如新生代）时效率极高。
     - **无碎片：** 复制后，存活对象在 To Space 中紧密排列，消除了内存碎片。
   - 缺点：
     - **空间利用率低：** 总有一半内存是空闲的（用于复制），实际可用内存只有总容量的一半。
     - **对象存活率高时效率低：** 如果对象存活率很高（如老年代），复制大量存活对象成本会很高。
   - **优化与应用：** HotSpot JVM 的**新生代回收（Minor GC）** 普遍采用此算法的优化版。它将新生代划分为一个较大的 **Eden 区**和两个较小的 **Survivor 区 (S0, S1)**。通常分配在 Eden 区，Minor GC 时将 Eden 和 S0 中存活的对象复制到 S1，然后清空 Eden 和 S0。下次 GC 时，则将 Eden 和 S1 的存活对象复制到 S0。这样只有 10% (两个 Survivor 各占 10%) 的空间被浪费。默认比例 `-XX:SurvivorRatio=8` 意味着 `Eden:S0:S1 = 8:1:1`。
3. **标记-整理算法 (Mark-Compact)**
   - 过程：
     1. **标记 (Mark)：** 与标记-清除算法相同，标记所有从 GC Roots 可达的对象。
     2. **整理 (Compact)：** 将所有存活的对象向内存的一端**移动**（“滑动”），保持它们的内存连续性。
     3. **清理：** 清理掉移动后边界以外的所有空间（即死亡对象占用的空间）。
   - 优点：
     - **无碎片：** 整理后内存规整，消除了碎片问题。
     - **空间利用率高：** 不像复制算法那样浪费一半空间。
   - 缺点：
     - **效率较低：** 移动存活对象需要更新所有指向这些对象的引用（指针），成本较高，且会导致较长的 STW (Stop-The-World) 停顿时间。
   - **应用：** 主要应用于**老年代回收（Major GC / Full GC）**，因为老年代对象存活率高，不适合复制算法。Serial Old, Parallel Old, G1（Full GC 时）等收集器使用此算法。

**二、常见的垃圾收集器**

JVM 提供了多种收集器，适用于不同场景（吞吐量优先、低延迟优先、内存大小等）。它们通常组合使用（新生代用 A，老年代用 B）。

1. **Serial / Serial Old**
   - **特点：** **单线程**收集器。进行垃圾回收时，会暂停所有用户线程（STW）。
   - **新生代 (Serial)：** 使用**复制算法**。
   - **老年代 (Serial Old)：** 使用**标记-整理算法**。
   - **优点：** 简单高效，在客户端模式或资源受限环境（如嵌入式）下，它是默认或较好的选择。**没有线程交互开销**。
   - **缺点：** **STW 时间长**，用户体验差，不适合服务端应用。
   - **启用参数：** `-XX:+UseSerialGC`
2. **ParNew**
   - **特点：** Serial 收集器的**多线程**版本。在新生代 GC 时，使用**多个线程**并行执行标记和复制（STW 期间并行）。老年代通常搭配 CMS 使用。
   - **算法：** 新生代使用**复制算法**（多线程并行）。
   - **优点：** 在**多核 CPU** 环境下，相比 Serial 能显著**缩短新生代 GC 的 STW 时间**。
   - **缺点：** 老年代搭配 CMS 时，ParNew GC 本身还是 STW 的。
   - **应用：** JDK 7 及之前与 CMS 搭配使用的首选新生代收集器。JDK 8+ 中逐渐被 G1 取代，在 JDK 9+ 中已被标记为废弃。
   - **启用参数：** `-XX:+UseParNewGC` (需与 `-XX:+UseConcMarkSweepGC` 搭配)
3. **Parallel Scavenge / Parallel Old (吞吐量优先收集器)**
   - **特点：** 关注点在于**达到可控制的吞吐量 (Throughput)**，即 `运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)`。也使用**多线程**并行 GC。
   - **新生代 (Parallel Scavenge)：** **复制算法**（多线程并行）。
   - **老年代 (Parallel Old, JDK6u18+ 开始提供)：** **标记-整理算法**（多线程并行）。
   - 优点：
     - 提供参数精确控制吞吐量 (`-XX:MaxGCPauseMillis` 最大停顿时间目标, `-XX:GCTimeRatio` 吞吐量目标)。
     - 多线程并行回收，适合后台运算、批处理任务等**对停顿时间不敏感但需要高吞吐量**的场景。
   - **缺点：** **牺牲了低延迟**，STW 时间不如 CMS/G1/ZGC 可控（尤其是在堆较大或老年代占比较高时）。
   - **启用参数：** `-XX:+UseParallelGC` / `-XX:+UseParallelOldGC` (通常一起使用) JDK 8 及之后的默认收集器。
4. **CMS (Concurrent Mark Sweep) (低延迟收集器 - 已废弃)**
   - **特点：** 目标是**最小化 STW 停顿时间**，尤其关注**老年代**回收的延迟。实现了**垃圾收集线程与用户线程（大部分时间）并发工作**。
   - **算法：** 老年代使用**标记-清除算法**（会导致碎片）。
   - 过程 (四个阶段，只有初始标记和重新标记需要 STW)：
     1. **初始标记 (Initial Mark - STW):** 仅标记 GC Roots **直接关联**的老年代对象。速度很快。
     2. **并发标记 (Concurrent Mark):** GC 线程与用户线程**并发**运行，从初始标记的对象出发，递归遍历整个对象图进行可达性分析。
     3. **重新标记 (Remark - STW):** 修正并发标记期间，因用户线程继续运行而导致标记产生变动的那部分对象（增量更新或原始快照 SATB）。停顿时间通常比初始标记稍长。
     4. **并发清除 (Concurrent Sweep):** GC 线程与用户线程**并发**运行，清除未被标记（死亡）的对象。
   - **优点：** **并发收集**，**低停顿**，用户体验较好，曾是很多互联网应用的选择。
   - 缺点：
     - **内存碎片：** 使用标记-清除，长时间运行后需要 Full GC（通常是 Serial Old）进行碎片整理，导致长时间 STW。
     - **对 CPU 资源敏感：** 并发阶段占用线程，会降低总吞吐量。
     - **无法处理浮动垃圾：** 并发清除阶段用户线程还在运行，可能产生新的垃圾（浮动垃圾），只能下次 GC 回收。
     - **"Concurrent Mode Failure"：** 如果在并发过程中老年代空间不足以容纳新晋升的对象，会触发 Full GC（Serial Old），导致长时间 STW。需预留足够空间 (`-XX:CMSInitiatingOccupancyFraction`)。
   - **启用参数：** `-XX:+UseConcMarkSweepGC` (JDK 9 开始废弃，JDK 14 中移除)。
5. **G1 (Garbage-First) (低延迟 & 高吞吐 - JDK9+ 默认)**
   - **特点：** **面向服务端应用**，设计目标是**在延迟可控的情况下获得尽可能高的吞吐量**。同时适用于新生代和老年代。
   - **核心思想：** 将堆划分为多个大小相等的独立区域 (Region)。G1 跟踪各个 Region 的回收价值（回收空间大小以及所需时间），优先回收垃圾最多的 Region（Garbage-First）。
   - **算法：** 整体基于**标记-整理算法**（避免 CMS 的碎片问题），局部（两个 Region 之间）基于**复制算法**。
   - 过程 (类似 CMS)：
     1. **初始标记 (Initial Mark - STW):** 标记 GC Roots 直接关联的对象。
     2. **并发标记 (Concurrent Mark):** 进行可达性分析。
     3. **最终标记 (Final Marking - STW):** 处理 SATB 记录，完成标记。
     4. **筛选回收 (Evacuation - STW):** 根据用户设定的最大停顿时间 (`-XX:MaxGCPauseMillis`)，选择回收价值最高的一组 Region 进行回收（复制存活对象到空 Region，整理）。这个阶段是**并行执行**的。
   - 优点：
     - **可预测的停顿模型：** 用户可以设定期望的最大 GC 停顿时间目标，G1 会尽力达成。
     - **内存碎片少：** 整体是标记-整理，避免了 CMS 的碎片问题。
     - **大堆友好：** 将堆分成 Region，回收时只回收部分 Region（Mixed GC），避免 Full GC（除非特殊情况如并发失败）。
   - **缺点：** 相比 CMS，G1 的 STW 阶段（尤其是筛选回收）可能稍长，但更可控；内存占用（Remembered Set / Collection Set）和写屏障开销略高。
   - **启用参数：** `-XX:+UseG1GC` (JDK 9 及之后版本的默认收集器)
6. **ZGC (The Z Garbage Collector) (超低延迟 - JDK15+ 生产可用)**
   - **目标：** 实现**亚毫秒级 (Sub-millisecond)** 的最大停顿时间 (STW < 10ms)，且停顿时间**不随堆大小或存活对象集大小而增加**。适用于超大堆 (TB 级别)。
   - 关键技术：
     - **着色指针 (Colored Pointers)：** 在指针中直接存储对象的引用状态信息（标记位），绕过传统 GC 需要对象头存储标记信息的限制。
     - **读屏障 (Load Barriers)：** 在读取引用时，执行少量额外代码检查指针颜色状态，决定是否需要触发或辅助 GC 操作（如重定位、标记）。这是并发执行的关键。
   - 过程 (几乎全程并发)：
     1. **并发标记 (Concurrent Marking)**
     2. **并发预备重分配 (Concurrent Prepare for Relocation)**
     3. **并发重分配 (Concurrent Relocation)：** **核心**，将存活对象移动到新的 Region (复制)。
     4. **并发重映射 (Concurrent Remapping)：** 修正所有指向重定位对象的旧引用。
   - 优点：
     - **极低停顿：** STW 停顿几乎完全被限制在 **Root 扫描**阶段（通常 <1ms）。
     - **堆大小无关的停顿：** 处理超大堆也能保持低延迟。
     - **高吞吐量：** 并发设计带来的额外开销相对可控。
   - **缺点：** 需要 JDK 11+ (生产建议 JDK 15+); 对特定硬件可能更敏感；与某些工具（如 JVMTI）的兼容性仍在完善；内存占用略高（特别是用于着色指针的虚拟内存）。
   - **启用参数：** `-XX:+UseZGC`
7. **Shenandoah (Red Hat 贡献，OpenJDK12+ 可用)**
   - **目标：** 与 ZGC 类似，追求**低停顿时间**（尤其 Full GC 停顿）和**堆大小无关的停顿**。
   - 关键技术：
     - **Brooks 指针：** 在每个对象前添加一个指向自身的新字段（转发指针），用于并发复制时处理引用。
     - **读屏障 & 写屏障：** 与 ZGC 类似，依赖屏障实现并发复制和引用更新。
   - **过程：** 与 ZGC 非常相似，主要阶段（标记、重定位/疏散、引用更新）也都是并发进行的。
   - **与 ZGC 区别：** Shenandoah 更早支持 **Generational** 模式（实验性）；在 JDK 版本支持策略上有所不同（Shenandoah 通常需要单独下载或特定 OpenJDK 发行版）。
   - **启用参数：** `-XX:+UseShenandoahGC`

**总结：**

- **算法是基础：** 标记-清除（碎片）、复制（高效但空间浪费）、标记-整理（无碎片但慢）是三大基石，现代收集器都是它们的组合或优化。
- 收集器演进：
  - **单线程 -> 多线程并行：** Serial -> ParNew/Parallel Scavenge/Old (提升吞吐量)。
  - **并行 -> 并发：** Parallel -> CMS (降低延迟，但碎片/并发失败)。
  - **分代 -> 分区：** CMS/Parallel -> G1 (解决碎片，可控停顿)。
  - **可控停顿 -> 极低停顿：** G1 -> ZGC/Shenandoah (亚毫秒级，堆大小无关)。
- **选择依据：** 需根据应用具体需求（吞吐量 vs 延迟）、堆大小、JDK 版本、硬件条件等综合选择。对于大多数现代服务端应用，**G1 是安全且优秀的选择 (JDK9+ 默认)**；对于超大堆和极致低延迟要求，**ZGC 或 Shenandoah 是未来方向**。